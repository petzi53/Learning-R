---
title: "OpenIntro Statistics: Introduction to data"
author: Peter Baumgartner
date: 2017-02-05
output: 
     github_document:
        toc: yes
        toc_depth: 3
---

```{r label = "global-options", echo=FALSE, highlight=TRUE}
knitr::opts_chunk$set(
        message = F,
        error = F,
        warning = F,
        comment = NA,
        highlight = T,
        prompt = T,
        cached = T
        )
```

# Data basics
## Get the data with base R as data frame

The Behavioral Risk Factor Surveillance System (BRFSS) is an annual telephone survey of 350,000 people in the United States. The [BRFSS Web site](http://www.cdc.gov/brfss) contains a complete description of the survey, including the research questions that motivate the study and many interesting results derived from the data.

Load the data set from the [OpenIntro Website](http://www.openintro.org/stat/data/cdc.R). 

* Have a look at the data in the browser to get a feeling of the raw data.
* Load the data set into R. As it is a big file (2.1 MB) check if it is already loaded into memory:
```{r get-cdc-data}
if (!exists("cdc")) {source("http://www.openintro.org/stat/data/cdc.R")}
```
The data set `cdc` that shows up in your workspace is a data matrix, with each row representing a case and each column representing a variable. R calls this data format a data frame, which is a term that will be used throughout the labs. 

## Get the data with tidyverse as tibble

But I will convert all data frames into to a `tibbles`. This has some advantages, explained in [R for Data Science](http://r4ds.had.co.nz/tibbles.html)

* It never changes an input’s type (i.e., no more stringsAsFactors = FALSE!).
* It never adjusts the names of variables (i.e. you can create names with blanks)
* It evaluates its arguments lazily and sequentially (i.e. you can calculate `y` from values of x during the creation)
* It never uses `row.names()`. The whole point of tidy data is to store variables in a consistent way. So it never stores a variable as special attribute.
* It only recycles vectors of length 1. This is because recycling vectors of greater lengths is a frequent source of bugs.
* When you print a tibble, it only shows the first ten rows and all the columns that fit on one screen. It also prints an abbreviated description of the column type.
* Tibbles are quite strict about subsetting. `[` always returns another tibble whereas d data frame sometimes returns a data frame and sometimes it just returns a vector.
* Tibbles are also stricter with $. as they never do partial matching (a common source of error).
* Tibbles ignore the drop argument.

Therefore I will call the matrix organisation of the data set "tibble" or abbreviated "tbl".


```{r covert-df-into-tibble}
library(tidyverse)
CDC <- tbl_df(cdc)
class(cdc)
class(CDC)
```
"cdc" (with small letters) has class "`r class(cdc)`", whereas "CDC" (with capital letters) now have "`r class(CDC)`" e.g. three classes at the same time to secure full compatiblity with data frames. 

## Explore the data
After loading the data and converting it into a tibble, one should inspect the data to get some understanding about the structure and content. Common funtions for these tasks are:

* `<name-of-data-tibble>`: Display the first 10 rows and all columns that fit on one screen. It also prints an abbreviated description of the column type.
* `head(<name-of-df>)`, `tail(<name-of-df>)`: Return the first or last part. Use these commands if it is not a tibble but a data frame
* `dim()`: Retrieve the dimension
* `names()`: Get the names
* `str()`: Display compactly the internal structure
* `glimpse()`: is the `dplyr`-version of `str()` showing values of each variable the whole sceen width, but does not display the number of levels and names of factor variables. But this feature of `str()` cannot be displayed completly with either many or long levels names.
* `View()`: With [RStudio](https://www.rstudio.com/) you can see and inspect the data set comfortably. The `View()` function invokes a spreadsheet-style data viewer.

You can see and inspect the data set comfortably in RStudio with the `View()` command, which invokes a spreadsheet-style data viewer on a matrix-like R object.
```{r explore-data-set}
CDC
head(CDC)
tail(CDC)
dim(CDC)
names(CDC)
str(CDC)
glimpse(CDC)
# View(CDC)
```

The tibble has 2000 observations (= rows) with 9 variables (columns). Each one of these variables corresponds to a question that was asked in the survey:

1. `genhlth`: respondents were asked to evaluate their general health, responding either excellent, very good, good, fair or poor. 
2. `exerany`: indicates whether the respondent exercised in the past month (1) or did not (0).
3. `hlthplan`: indicates whether the respondent had some form of health coverage (1) or did not (0). 
4. `smoke100`: indicates whether the respondent had smoked at least 100 cigarettes in her lifetime. 
5. `height`: in inches
6. `weight`: in pounds 
7. `wtdesire`: desired weight 
8. `age` in years
9. `gender`: "m" or "f"

## Exercise 1
How many cases are there in this data set? How many variables? For each variable, identify its data type (e.g. categorical, discrete).

**My Solution**: 

 0. There are `r nrow(CDC)` cases (= observations) and `r ncol(CDC)` variables in the CDC data set.

1. `genhlth`: excellent, very good, good, fair or poor = categorial
2. `exerany`: past month (1) or not (0) = categorial
3. `hlthplan`: some form of health coverage (1) or not (0) = categorial
4. `smoke100`: had smoked at least 100 cigarettes in her lifetime = categorial
5. `height`: in inches = continous
6. `weight`: in pounds = continous
7. `wtdesire`: desired weight = continuos
8. `age` in years = discrete
9. `gender`: "m" or "f" = categorial

# Summaries and tables
## Summaries of numerical data with base R: `summary()`
A good first step in any analysis is to distill all of that information into a few summary statistics and graphics. As a simple example, the function summary returns a numerical summary: minimum, first quartile, median, mean, second quartile, and maximum. For weight this is:
```{r summary-of-weight}
summary(CDC$weight)
```
## Summaries of numerical data with `dplyr`: `summarise()`

`dplyr` does not have its own special methods for R summary function (see last sentence of vignette [Introduction to dplyr](https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html). But you can use the R base functions with `dplyr` and some other extra functions supplied by `dplyr`. Besides functions in base R like `min()`, `max()`, `mean()`, `sum()`, `sd()`, `median()`, and `IQR()`. dplyr provides a handful of others:

* `n()`: the number of observations in the current group
* `n_distinct(x)`:the number of unique values in x.
* `first(x)`, `last(x)` and `nth(x, n) - these work similarly to x[1], x[length(x)], and x[n] but give you more control over the result if the value is missing.
```{r dplyr-equivalent-of-summarise}
summarise(CDC, Min. = min(weight), "1st Qu." = quantile(weight, probs = 0.25), Median = median(weight), Mean = mean(weight), "3rd Qu." = quantile(weight, probs = 0.75), Max = max(weight))
```
The `dplyr`-equivalent of base R `summary()` is more complex, but has more control about functions used, their names in the table, their sequence etc. So we could add for instance `sd()`, `var()`, `IQR()`. To get these extra values with the base R functions one would have to be write different lines of code.
```{r dplyr-summarise-many-statistics}
summarise(CDC, Min. = min(weight), 
          "1st Qu." = quantile(weight, probs = 0.25), 
          Median = median(weight), Mean = mean(weight), 
          "3rd Qu." = quantile(weight, probs = 0.75), 
          Max = max(weight), Var = var(weight), 
          SD = sd(weight), 
          IQR = IQR(weight)
          )
```
But the great advantage for `summarise()` lies int the combination with the `group_by()` function of `dplyr` (see the examples in the [Introduction to dplyr](https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html) vignette.)

## Summaries of categorical data with base R: `table()`

While it makes sense to describe a quantitative variable like `weight` in terms of these statistics, what about categorical data? We would instead consider the sample frequency or relative frequency distribution. The function table does this for you by counting the number of times each kind of response was given. For example, to see the number of people who have smoked 100 cigarettes in their lifetime or instead look at the relative frequency distribution.
```{r generate-contingency-tables-with-base-r-table}
table(CDC$smoke100)
table(CDC$smoke100) / 20000
```
Notice how R automatically divides all entries in the table by 20,000 in the command above. This is similar to something we observed in the Introduction to R; when we multiplied or divided a vector with a number, R applied that action across entries in the vectors. As we see above, this also works for tables.

## Summaries of categorical data with `dplyr`: `count()`
But the outcome of the `table()` command is class "`r class(table(CDC$smoke100))`" which is not so easy to work with as a data frame or a tibble. (See the article on [R-bloggers](https://www.r-bloggers.com/how-to-get-the-frequency-table-of-a-categorical-variable-as-a-data-frame-in-r/).) It is better to use the `count()` function of `dplyr`, because it adds the column names and returns – as all dply-functions — a tibble. Furthermore the relative frequency distribution (the propoartion) can be added as a new column in one command.

```{r generate-contingency-tables-with-dplyr-count}
CDC %>% 
        count(smoke100) %>%
        mutate(prop = n / nrow(CDC))
```
**Questions:** 

* How to limit the figure of `prop` to an accuracy of two digits after the decimal point?
* How to use "." for big figures and "," for German localisation?

## Graphical summary with base R: `barplot()`

Next, we make a bar plot of the entries in the table by putting the table inside the `barplot()` command.
```{r generate-a-barplot}
barplot(table(CDC$smoke100))
```
Notice what we’ve done here! We’ve computed the table of cdc$smoke100 and then immediately applied the graphical function, barplot. This is an important idea: R commands can be nested. You could also break this into two steps by typing the following:

```{r generate-a-barplot-from-a-table-object}
smoke <- table(CDC$smoke100)
barplot(smoke)
```

Here, we’ve made a new object, a table, called `smoke` (the contents of which we can see by typing `smoke` into the console) and then used it in as the input for barplot. The special symbol `<-` performs an assignment, taking the output of one line of code and saving it into an object in your workspace.

## Graphical summary with `ggplot2`: `ggplot()`

A basic bar chart is drawn with `geom_bar()`. The following chart displays the total number of poeple in the CDC dataset, grouped by `smoke100`.The chart shows that slightly more people of the sample haven`t even smoked 100 ciragettes during their lifetime.


```{r generate-a-barplot-with-geom}
ggplot(data = CDC) + 
  geom_bar(mapping = aes(x = smoke100))
```
On the x-axis, the chart displays `smoke100`, a variable from `CDC`. On the y-axis, it displays count, but count is not a variable in `CDC`! Where does count come from? Many graphs, like scatterplots, plot the raw values of your dataset. Other graphs, like bar charts, calculate new values to plot:

* bar charts, histograms, and frequency polygons bin your data and then plot bin counts, the number of points that fall in each bin.
* smoothers fit a model to your data and then plot predictions from the model.
* boxplots compute a robust summary of the distribution and then display a specially formatted box.

The algorithm used to calculate new values for a graph is called a `stat`, short for statistical transformation. You can learn which `stat a `geom` uses by inspecting the default value for the `stat` argument. For example, `?geom_bar` shows the default value for `stat` is “count”, which means that `geom_bar()` uses `stat_count()`. `stat_count()` is documented on the same page as `geom_bar()`, and if you scroll down you can find a section called “Computed variables”. That tells that it computes two new variables: `count` and `prop`.

ou can generally use `geoms` and `stats` interchangeably. For example, you can recreate the previous plot using `stat_count()` instead of `geom_bar()`:

```{r generate-a-barplot-with-stat}
ggplot(data = CDC) + 
  stat_count(mapping = aes(x = smoke100))
```
This works because every `geom` has a default `stat`; and every `stat` has a default `geom`. This means that you can typically use geoms without worrying about the underlying statistical transformation. Sometimes you might need to use a stat explicitly: For instance when you want to override the default mapping from transformed variables to aesthetics. For example, you might want to display a bar chart of proportion, rather than count:


```{r generate-a-barplot-with-prop}
ggplot(data = CDC) + 
        stat_count(mapping = aes(x = smoke100, y = ..prop..), 
                   fill='lightblue', color = 'black')
```

## Exercise 2

* Create a numerical summary for `height` and `age`, and compute the interquartile range for each. 
* Compute the relative frequency distribution for `gender` and `exerany`. 
* How many males are in the sample? 
* What proportion of the sample reports being in excellent health?

**My Solution**:
```{r exercise-2, echo=FALSE}
cat("Using base R: height\n")
summary(CDC$height)
cat("               IQR for height:", IQR(CDC$height), "\n\n")
cat("Using base R: age\n")
summary(CDC$age)
cat("               IQR for age:", IQR(CDC$age), "\n\n")

table(CDC$gender)
table(CDC$gender) / 20000
table(CDC$exerany) / 20000
table(CDC$genhlth) / 20000


cat("Using dplyr: height\n")
summarise(CDC, Min. = min(height), 
          "1st Qu." = quantile(height, probs = 0.25), 
          Median = median(height), Mean = mean(height), 
          "3rd Qu." = quantile(height, probs = 0.75), 
          Max = max(height), 
          IQR = IQR(height)
          )

cat("Using dplyr: age\n")
summarise(CDC, Min. = min(age), 
          "1st Qu." = quantile(age, probs = 0.25), 
          Median = median(age), Mean = mean(age), 
          "3rd Qu." = quantile(age, probs = 0.75), 
          Max = max(age), 
          IQR = IQR(age)
          )

# table(CDC$genhlth) / 20000)

# CDC %>% 
#         count(gender) %>%
#         mutate(prop = n / 20000)
```
**Questions:**

* How to limit Mean to two digits after the decimal point? [solved: using round, but I had in combination of subsetting I had to convert the table to a vector and then to a double.]
* How to write a function to simulate the `summary())` function using `dplyr` commands. 
* How to subset just one figure of the contingengy table for use in inline text. [solved: convert table to vector and subset]

There are `r as.vector(table(CDC$gender))[1]` males in the sample.
`r round(as.double(as.vector(table(CDC$genhlth) / 20000)[1] * 100), digits = 2)`% of the sample reports being in excellent health.

The table command can be used to tabulate any number of variables that you provide. For example, to examine which participants have smoked across each gender, we could use the following.

```{r contingengy-table}
table(Gender = CDC$gender, Smoke100 = CDC$smoke100)
```
Here, we see column labels of 0 and 1. Recall that 1 indicates a respondent has smoked at least 100 cigarettes. [I have the table labelled.]

**Question:** 
How to provide tables more beautiful?

```{r multivariable-table}
table(Gender = CDC$gender, Smoke100 = CDC$smoke100, Exercises = CDC$exerany)
```
[Here I have added another varialbe to see how R presents the results.]

To create a mosaic plot of this table, we would enter the following command:
```{r}
mosaicplot(table(Gender = CDC$gender, Smoke100 = CDC$smoke100))
```

## Exercise 3
What does the mosaic plot reveal about smoking habits and gender?

**My Solution**:

A higher proportion of females said that they didn't smoke more than 100 cigarettes in their lifetime.

# Subsetting

Interlude (= some commands to inspect data and data structure) and subsetting is something I have already experiences. Therefore I will not go into much detail.

Suppose we want to extract just the data for the men in the sample, or just for those over 30. We can use the R function subset to do that for us. For example, the command

```{r subsetting-with-subset-and-filter}
mdata <- subset(CDC, CDC$gender == "m")
mdata1 <- filter(CDC, gender == "m")
```

will create a new data set called mdata that contains only the men from the CDC data set. In addition to finding it in your workspace alongside its dimensions, you can take a peek at the first several rows as usual.
```{r}
head(mdata1, 10)
```
You can use several of these conditions together with `&` and `|`. The `&` is read “and” so that

```{r}
m_and_over30 <- subset(CDC, gender == "m" & age > 30)
m_and_over30_1 <- filter(CDC, gender == "m" & age > 30)
```

will give you the data for men over the age of 30. The `|` character is read “or” so that

```{r}
m_or_over30 <- subset(CDC, gender == "m" | age > 30)
m_or_over30_1 <- filter(CDC, gender == "m" & age > 30)
```

will take people who are men or over the age of 30 (why that’s an interesting group is hard to say, but right now the mechanics of this are the important thing). In principle, you may use as many “and” and “or” clauses as you like when forming a subset.

## Exercise 4
Create a new object called under23_and_smoke that contains all observations of respondents under the age of 23 that have smoked 100 cigarettes in their lifetime. Write the command you used to create the new object as the answer to this exercise.
```{r exercise-4}
under23_and_smoke <- subset(CDC, age < 23 & smoke100 == 1)
under23_and_smoke_1 <- filter(CDC, age < 23 & smoke100 == 1)
```

# Quantitative data
With our subsetting tools in hand, we’ll now return to the task of the day: making basic summaries of the BRFSS questionnaire. We’ve already looked at categorical data such as smoke and gender so now let’s turn our attention to quantitative data. Two common ways to visualize quantitative data are with box plots and histograms. 

To get a better feeling of the data I will add three new rows: `height_cm`, `weight_kg`, `wtdesire_kg.

* 1 inch = 2.54 cm
* 1 pound = 0.453592 kg

```{r}
cdc_metric <- CDC %>%
                mutate(height_cm = as.integer(round(height * 2.54))) %>%
                mutate(weight_kg = as.integer(round(weight * 0.453592))) %>%
                mutate(wtdesire_kg = as.integer(round(wtdesire * 0.453592)))
```


We can construct a box plot for a single variable. You can compare the locations of the components of the box by examining the summary statistics.

```{r boxplot-single-variable}
boxplot(cdc_metric$height_cm)
summary(cdc_metric$height_cm)
```

With ggplot you need x and y, e.g. two variables: see [StackOverflow](http://stackoverflow.com/questions/25049104/why-does-a-boxplot-in-ggplot-requires-axis-x-and-y)).
```{r qplot-with-one-variable}
qplot(y = height_cm,
      x = 1,
      data = cdc_metric,
      geom = "boxplot")
```

```{r ggplot-with-one-variable}
ggplot(cdc_metric, aes(x = "", y = height_cm)) + 
        geom_boxplot()
summary(cdc_metric$height_cm)
```
Confirm that the median and upper and lower quartiles reported in the numerical summary match those in the graph. The purpose of a boxplot is to provide a thumbnail sketch of a variable for the purpose of comparing across several categories. So we can, for example, compare the heights of men and women with
```{r height-m-and-f-with-boxplot-and-base-r}
boxplot(cdc_metric$height_cm ~ cdc_metric$gender)
summary(subset(cdc_metric, gender == "m", select = height_cm))
summary(subset(cdc_metric, gender == "f", select = height_cm))
```
```{r height-m-and-f-with-ggplot-and-dplyr}
ggplot(cdc_metric, aes(x = gender, y = height_cm)) + 
        geom_boxplot()
summarise(group_by(cdc_metric, gender), 
          Min. = min(height_cm), 
          "1st Qu." = quantile(height_cm, probs = 0.25), 
          Median = median(height_cm), Mean = round(mean(height_cm), digits = 2), 
          "3rd Qu." = quantile(height_cm, probs = 0.75), 
          Max = max(height_cm), 
          IQR = IQR(height_cm)
          )
```
```{r}
bmi <- (CDC$weight / CDC$height^2) * 703
boxplot(bmi ~ CDC$genhlth)
```

```{r my-bmi}
(my_bmi <- (88 / 1.79^2))
```


